{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/ISafeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./ISafeVault.sol\";\n\n/// @title  ISafeToken\n/// @author crypt0grapher\n/// @notice This contract is used as a token\ninterface ISafeToken is IERC20, IERC20Metadata {\n\n    /**\n    *   @notice buy SAFE tokens for given amount of USD, taxes deducted from the provided amount, SAFE is minted\n    *   @param _usdToSpend number of tokens to buy, the respective amount of USD will be deducted from the user, Safe Yield token will be minted\n    */\n    function buySafeForExactAmountOfUSD(uint256 _usdToSpend) external returns (uint256);\n\n    /**\n    *   @notice calculate and deduct amount of USD needed to buy given amount of SAFE tokens, SAFE is minted\n    *   @param _safeTokensToBuy number of tokens to buy, the respective amount of stable coin  will be deducted from the user, Safe Yield token will be minted\n    */\n    function buyExactAmountOfSafe(uint256 _safeTokensToBuy) external;\n\n    /**\n    *   @notice sell given amount of SAFE tokens for USD, taxes deducted from the user, SAFE is burned\n    *   @param _safeTokensToSell number of tokens to sell, the respective amount of stable coin  will be returned from the user, Safe Yield token will be burned\n    */\n    function sellExactAmountOfSafe(uint256 _safeTokensToSell) external;\n\n    /**\n    *   @notice calculate the amount of SAFE needed to swap to get the exact USD amount, SAFE is burned USD redeemed from the vault\n    *   @param _usdToGet number of tokens to buy, the respective amount of stable coin  will be deducted from the user, Safe Yield token will be minted\n    */\n    function sellSafeForExactAmountOfUSD(uint256 _usdToGet) external;\n\n    /**\n    *   @notice admin function, currently used only to deposit 1 SAFE token to the Safe Vault to set the start price\n    */\n    function mint(address usr, uint256 wad) external;\n\n    /**\n    *   @notice admin function\n    */\n    function burn(address usr, uint256 wad) external;\n\n    /**\n    *   @notice list of wallets participating in tax distribution on top of the vault\n    */\n    function getWallets() external view returns (address[2] memory);\n\n    /**\n    *   @notice stable coin token contract used in the protocol\n    */\n    function usd() external view returns (IERC20);\n\n    /**\n*   @notice attached safe vault contract\n    */\n    function safeVault() external view returns (ISafeVault);\n\n    /**\n    *   @notice price of 1 Safe Yield token in StableCoin\n    */\n    function price() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISafeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\n/// @title  ISafeVault\n/// @author crypt0grapher\n/// @notice Safe Yield Vault depositing to the third-party yield farms\ninterface ISafeVault {\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n\n    // @notice deposit stable coin  to the vault from the sender\n    // @param _amount amount of stable coin  to deposit\n    function deposit(uint256 _amount) external;\n\n    // @notice Withdraw stable coin  from the vault to the receiver from the function caller (msg.sender)\n    // @param _user user to send tokens to, withdrawn from the sender\n    // @param _amount amount of stable coin  to withdraw\n    function withdraw(address _user, uint256 _amount) external;\n\n    // @notice totalSupply of the vault, total amount of the stablecoin in the vault, including deposits and other tokens transferred to the vault\n    // @return total supply of the vault\n    function totalSupply() external view returns (uint256);\n\n    // @notice totalSupply of the vault\n    // @return total supply of the vault\n    function deposited() external view returns (uint256);\n\n}\n"
    },
    "contracts/Owned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\n/// @title  Safe NFT\n/// @author crypt0grapher\n/// @notice Safe Yields NFT token based on ERC1155 standard, id [0..3] represents one of the 4 tiers\n\ncontract Owned {\n    /// @dev this is getting the owner from the proxy contract, the proxy contract is ERC-173 compliant and support transferOwnership\n    /// @dev service function used by children contracts which are at least SafeVault.sol and SafeToken.sol\n    function _getOwner() internal view returns (address adminAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            adminAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"
    },
    "contracts/SafeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport \"./interfaces/ISafeToken.sol\";\nimport \"./interfaces/ISafeVault.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./Wallets.sol\";\nimport \"./Owned.sol\";\n\n/// @title  SafeToken\n/// @author crypt0grapher\n/// @notice This contract is used as a token for the SafeYields protocol\ncontract SafeToken is ISafeToken, Owned, Wallets, Proxied, Pausable, ReentrancyGuard {\n    // @notice ERC20 token data\n    string public constant name = \"Safe Yields Token\";\n    string public constant symbol = \"SAFE\";\n    string public constant version = \"1\";\n    uint8 public constant decimals = 6;\n\n    /// @notice Total supply of the token, the ratio of totalSupply of the vault by the totalSupply of the Safe Token defines the price of the token\n    uint256 public totalSupply;\n\n    /// @notice Whitelisted addresses for transfers, contains protocol contracts and selected partners\n    /// @dev if not included into the list, transfer is prohibited\n    mapping(address => bool) public whitelist;\n\n    // @notice Balances of each user\n    mapping(address => uint256) public balanceOf;\n\n    // @notice Approved allowances\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    // @notice Taxes, multiplied by 10000, (25 stands for 0.25%)\n    uint256 public BUY_TAX_PERCENT;\n    uint256 public SELL_TAX_PERCENT;\n\n    // @notice core protocol addresses\n    IERC20 public usd;\n    ISafeVault public safeVault;\n\n    // @notice tax distribution percentages, multiplied by 10000, (25 stands for 0.25%)\n    uint256[WALLETS] public taxDistributionOnMintAndBurn;\n\n    /* ============ Modifiers ============ */\n\n    modifier auth() {\n        require(_msgSender() == _getOwner(), \"SafeToken:not-authorized\");\n        _;\n    }\n\n    /* ============ Changing State Functions ============ */\n\n    /// @dev this one is called by the proxy\n    function initialize(address _usdToken, address _safeVault, address[WALLETS] memory _wallets, uint256[WALLETS] memory _taxDistributionOnMintAndBurn, uint256 _buyTaxPercent, uint256 _sellTaxPercent) public proxied {\n        whitelist[_msgSender()] = true;\n        safeVault = ISafeVault(_safeVault);\n        usd = IERC20(_usdToken);\n        _setWallets(_wallets);\n        taxDistributionOnMintAndBurn = _taxDistributionOnMintAndBurn;\n        BUY_TAX_PERCENT = _buyTaxPercent;\n        SELL_TAX_PERCENT = _sellTaxPercent;\n        usd.approve(address(safeVault), type(uint256).max);\n    }\n\n    constructor(address _usdToken, address _safeVault, address[WALLETS] memory _wallets, uint256[WALLETS] memory _taxDistributionOnMintAndBurn, uint256 _buyTaxPercent, uint256 _sellTaxPercent)  {\n        initialize(_usdToken, _safeVault, _wallets, _taxDistributionOnMintAndBurn, _buyTaxPercent, _sellTaxPercent);\n    }\n\n    function transfer(address dst, uint256 amt) external returns (bool) {\n        return transferFrom(_msgSender(), dst, amt);\n    }\n\n    function getWallets() external view returns (address[WALLETS] memory) {\n        return wallets;\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) public nonReentrant returns (bool) {\n        address sender = _msgSender();\n        address admin = _getOwner();\n        require(!paused(), \"SafeToken:paused\");\n        require(whitelist[src] == true || whitelist[dst] == true || admin == sender, \"SafeToken: transfer-prohibited\");\n        require(balanceOf[src] >= amt, \"SafeToken:insufficient-balance\");\n        require(dst != address(0) && src != address(0), \"SafeToken:zero-address\");\n        if (src != sender && sender != admin) {\n            require(allowance[src][sender] >= amt, \"SafeToken:insufficient-allowance\");\n            allowance[src][sender] -= amt;\n        }\n        balanceOf[src] -= amt;\n        balanceOf[dst] += amt;\n        emit Transfer(src, dst, amt);\n        return true;\n    }\n\n\n    function mint(address _user, uint256 _amount) external auth {\n        _mint(_user, _amount);\n    }\n\n    function burn(address _user, uint256 _amount) external auth {\n        _burn(_user, _amount);\n    }\n\n\n    function buySafeForExactAmountOfUSD(uint256 _usdToSpend) public nonReentrant returns (uint256) {\n        uint256 usdTax = _usdToSpend * BUY_TAX_PERCENT / HUNDRED_PERCENT;\n        uint256 usdToSwapForSafe = _usdToSpend - usdTax;\n        uint256 safeTokensToBuy = (usdToSwapForSafe * 1e6) / price();\n        _mint(_msgSender(), safeTokensToBuy);\n        bool success = usd.transferFrom(_msgSender(), address(this), _usdToSpend);\n        // that's for compatibility, usually if the transfer fails, it reverts but that's not the obligation of ERC20\n        require(success, \"SafeToken:transfer-failed\");\n        // distributing to wallets (if any, currently it's treasury and management)\n        // it's not 100% in total, although could be the case\n        uint256 paid = _distribute(usd, usdTax, taxDistributionOnMintAndBurn);\n        safeVault.deposit(usdToSwapForSafe + usdTax - paid);\n        return safeTokensToBuy;\n    }\n\n    function buyExactAmountOfSafe(uint256 _safeTokensToBuy) public nonReentrant {\n        uint256 usdPriceOfTokensToBuy = _safeTokensToBuy * price() / 1e6;\n        uint256 usdTax = usdPriceOfTokensToBuy * BUY_TAX_PERCENT / HUNDRED_PERCENT;\n        uint256 usdToSpend = usdPriceOfTokensToBuy + usdTax;\n        _mint(_msgSender(), _safeTokensToBuy);\n        bool success = usd.transferFrom(_msgSender(), address(this), usdToSpend);\n        require(success, \"SafeToken:transfer-failed\");\n        uint256 paid = _distribute(usd, usdTax, taxDistributionOnMintAndBurn);\n        if (usdToSpend - paid > 0) {\n            safeVault.deposit(usdToSpend - paid);\n        }\n    }\n\n\n    function sellExactAmountOfSafe(uint256 _safeTokensToSell) public nonReentrant {\n        uint256 usdPriceOfTokensToSell = _safeTokensToSell * price() / 1e6;\n        uint256 usdTax = usdPriceOfTokensToSell * SELL_TAX_PERCENT / HUNDRED_PERCENT;\n        uint256 usdToReturn = usdPriceOfTokensToSell - usdTax;\n        _burn(_msgSender(), _safeTokensToSell);\n        safeVault.withdraw(_msgSender(), usdToReturn);\n        safeVault.withdraw(address(this), usdTax);\n        uint256 paid = _distribute(usd, usdTax, taxDistributionOnMintAndBurn);\n        if (usdTax - paid > 0) {\n            safeVault.deposit(usdTax - paid);\n        }\n    }\n\n    function sellSafeForExactAmountOfUSD(uint256 _usdToPayToUser) public nonReentrant {\n        uint256 usdTax = _usdToPayToUser * SELL_TAX_PERCENT / (HUNDRED_PERCENT - SELL_TAX_PERCENT);\n        uint256 usdPriceWithTax = _usdToPayToUser + usdTax;\n        uint256 safeTokensToBurn = (usdPriceWithTax * 1e6) / price();\n        _burn(_msgSender(), safeTokensToBurn);\n        safeVault.withdraw(_msgSender(), _usdToPayToUser);\n        safeVault.withdraw(address(this), usdTax);\n        uint256 paid = _distribute(usd, usdTax, taxDistributionOnMintAndBurn);\n        if (usdTax - paid > 0)\n            safeVault.deposit(usdTax - paid);\n    }\n\n    function approve(address usr, uint256 amt) external returns (bool) {\n        allowance[_msgSender()][usr] = amt;\n        emit Approval(_msgSender(), usr, amt);\n        return true;\n    }\n\n    function whitelistAdd(address guy) external auth {\n        whitelist[guy] = true;\n    }\n\n    function whiteListRemove(address guy) external auth {\n        whitelist[guy] = false;\n    }\n\n    function pause() external auth {\n        _pause();\n    }\n\n    function unpause() external auth {\n        _unpause();\n    }\n\n    /* ============ View Functions ============ */\n\n    /// @dev this is intentional that not deposited() is used, because the total amount of USD in the vault is used to calculate the price\n    function getUsdReserves() public view returns (uint256) {\n        return safeVault.totalSupply();\n    }\n\n    /// @dev the key is the price is usd reserves, so not only user deposits from safe purchase, but also injections from the NFT purchase and treasury if needed\n    function price() public view returns (uint256) {\n        return (totalSupply == 0) ? 1e6 : getUsdReserves() * 1e6 / totalSupply;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _mint(address usr, uint256 amount) internal {\n        balanceOf[usr] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), usr, amount);\n    }\n\n    function _burn(address usr, uint256 amount) internal {\n        require(balanceOf[usr] >= amount, \"SafeToken:insufficient-balance\");\n        address sender = _msgSender();\n        if (_getOwner() != sender && usr != sender && allowance[usr][sender] != type(uint256).max) {\n            require(allowance[usr][sender] >= amount, \"SafeToken:insufficient-allowance\");\n            allowance[usr][sender] -= amount;\n        }\n        balanceOf[usr] -= amount;\n        totalSupply -= amount;\n        emit Transfer(usr, address(0), amount);\n    }\n\n}\n"
    },
    "contracts/Wallets.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Wallets {\n    /// @dev precision constant, stands as 100%\n    uint256 public constant HUNDRED_PERCENT = 100_000_000;\n\n    /// @notice total wallets on the protocol less vault, see Wallets enum, this can be basically any number\n    /// @dev this is used for the loop in the distribution function, vault gets the rest\n    uint256 public constant WALLETS = 2;\n\n    // @notice token wallets configuration\n    address[WALLETS] public wallets;\n\n    /// @notice protocol wallets for easy enumeration,\n    /// @dev the order is extremely important once deployed, see configuration scripts, rewards distribution is the balance of SafeNFT,\n    enum WalletsUsed {\n        Treasury,\n        Management\n    }\n\n    function _setWallets(address[WALLETS] memory _wallets) internal {\n        wallets = _wallets;\n    }\n\n    /// @notice Distribution percentages, multiplied by 10000, (25 stands for 0.25%)\n    /// @dev walletPercentageDistribution is intentionally storage since this is called from the child contract to avoid unnecessary copy to memory\n    /// @dev walletPercentageDistribution has different meaning in the child contracts, but always the same length and kept in storage\n    function _distribute(IERC20 _paymentToken, uint256 _amount, uint256[WALLETS] storage walletPercentageDistribution) internal returns (uint256) {\n        uint256 amountPaid = 0;\n\n        for (uint256 i = 0; i < WALLETS; i++) {\n            uint256 amount = (_amount * walletPercentageDistribution[i]) / HUNDRED_PERCENT;\n            _paymentToken.transfer(wallets[i], amount);\n            amountPaid += amount;\n        }\n        return amountPaid;\n    }\n\n    // @notice Distribution percentages, multiplied by 10000, (25 stands for 0.25%)\n    function _transferPercent(IERC20 _paymentToken, uint256 _amount, address _receiver, uint256 _percent) internal returns (uint256) {\n        uint256 balance = _paymentToken.balanceOf(address(this));\n        uint256 amount = (_amount * _percent) / HUNDRED_PERCENT;\n        require(balance >= amount, \"Not enough balance on the contract\");\n        _paymentToken.transfer(_receiver, amount);\n        return amount;\n    }\n\n    function _getTotalShare(uint256 _amount, uint256[WALLETS] storage _walletPercentageDistribution, uint256 _extraShare) internal view returns (uint256) {\n        uint256 totalPercentage = 0;\n        //reducing sload calls\n        uint256 WALLETS_mem = WALLETS;\n        for (uint256 i = 0; i < WALLETS_mem; i++) {\n            totalPercentage += _walletPercentageDistribution[i];\n        }\n        totalPercentage += _extraShare;\n        return _amount * totalPercentage / HUNDRED_PERCENT;\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/proxy/Proxied.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address ownerAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 250
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "berlin",
    "metadata": {
      "useLiteralContent": true
    }
  }
}